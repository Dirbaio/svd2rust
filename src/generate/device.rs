use proc_macro2::{Ident, Span, TokenStream};
use quote::{quote, ToTokens};

use crate::util::{self, ToSanitizedUpperCase};
use crate::Target;
use anyhow::Result;

use crate::ir::*;

pub fn render(d: &Device, target: Target) -> Result<TokenStream> {
    let mut out = TokenStream::new();

    let commit_info = {
        let tmp = include_str!(concat!(env!("OUT_DIR"), "/commit-info.txt"));

        if tmp.is_empty() {
            " (untracked)"
        } else {
            tmp
        }
    };

    let doc = format!(
        "Peripheral access API for {0} microcontrollers \
         (generated using svd2rust v{1}{2})\n\n\
         You can find an overview of the generated API [here].\n\n\
         API features to be included in the [next] svd2rust \
         release can be generated by cloning the svd2rust [repository], \
         checking out the above commit, and running `cargo doc --open`.\n\n\
         [here]: https://docs.rs/svd2rust/{1}/svd2rust/#peripheral-api\n\
         [next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n\
         [repository]: https://github.com/rust-embedded/svd2rust",
        d.name.to_uppercase(),
        env!("CARGO_PKG_VERSION"),
        commit_info
    );

    if target == Target::Msp430 {
        out.extend(quote! {
            #![feature(abi_msp430_interrupt)]
        });
    }

    out.extend(quote! {
        #![doc = #doc]
        // Explicitly allow a few warnings that may be verbose
        #![allow(non_camel_case_types)]
        #![allow(non_snake_case)]
        #![no_std]
    });

    // Retaining the previous assumption
    let mut fpu_present = true;

    if let Some(cpu) = d.cpu.as_ref() {
        let bits = util::unsuffixed(u64::from(cpu.nvic_priority_bits));

        out.extend(quote! {
            ///Number available in the NVIC for configuring priority
            pub const NVIC_PRIO_BITS: u8 = #bits;
        });

        fpu_present = cpu.fpu_present;
    }

    //out.extend(interrupt::render(target, &d.interrupts, device_x)?);

    let core_peripherals: &[_] = if fpu_present {
        &[
            "CBP", "CPUID", "DCB", "DWT", "FPB", "FPU", "ITM", "MPU", "NVIC", "SCB", "SYST", "TPIU",
        ]
    } else {
        &[
            "CBP", "CPUID", "DCB", "DWT", "FPB", "ITM", "MPU", "NVIC", "SCB", "SYST", "TPIU",
        ]
    };

    let mut fields = TokenStream::new();
    let mut exprs = TokenStream::new();
    if target == Target::CortexM {
        out.extend(quote! {
            pub use cortex_m::peripheral::Peripherals as CorePeripherals;
            #[cfg(feature = "rt")]
            pub use cortex_m_rt::interrupt;
            #[cfg(feature = "rt")]
            pub use self::Interrupt as interrupt;
        });

        if fpu_present {
            out.extend(quote! {
                pub use cortex_m::peripheral::{
                    CBP, CPUID, DCB, DWT, FPB, FPU, ITM, MPU, NVIC, SCB, SYST, TPIU,
                };
            });
        } else {
            out.extend(quote! {
                pub use cortex_m::peripheral::{
                    CBP, CPUID, DCB, DWT, FPB, ITM, MPU, NVIC, SCB, SYST, TPIU,
                };
            });
        }
    }

    if target == Target::Msp430 {
        out.extend(quote! {
            // XXX: Are there any core peripherals, really? Requires bump of msp430 crate.
            // pub use msp430::peripheral::Peripherals as CorePeripherals;
            #[cfg(feature = "rt")]
            pub use msp430_rt::interrupt;
            #[cfg(feature = "rt")]
            pub use self::Interrupt as interrupt;
        });
    }

    /*
    for p in &d.instances {
        out.extend(super::instance::render(p)?);
    }

    for p in &d.peripherals {
        out.extend(super::peripheral::render(p)?);
    }
     */

    Ok(out)
}
